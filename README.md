# 栈
## 后进先出
    
   ## 用数组模拟，要记录栈顶
    
   ## 常用操作：向栈顶插入一个数，从栈顶弹出，判断栈顶是否为空
    
   ## int stk[N], tt = -1;
    
   ## 插入一个数：stk[++ tt] = x;
   ## 弹出：tt --;
    
   ## 判断栈是否为空：
   ###  if (tt > 0) ;// not empty;
   ###  else ;// empty;
   ## 栈顶：stk[tt];
   ## 题目：acwing 3302. 表达式求值：给定一个表达式，其中运算符仅包含 +,-,*,/（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。
   ###  核心思想：利用栈转化为后缀表达式，之后再次利用栈计算出结果（逆波兰算法）
   ###  转化为后缀表达式：
            1.所有的数字直接输出
            2.运算符优先级高于栈内的要入栈（或栈空）。否则，从堆栈中弹出所有优先级更高或一样的运算符（或直到括号），再将当前的入栈
            3.所有左括号都要入栈
            4.若是右括号，则不断出栈，直到碰到左括号

   ###  计算后缀表达式：
            1.从左到右扫描表达式，如果当前字符为数字，则入栈
            2.如果当前字符为运算符，则将栈顶两个元素出栈，作相应运算，结果再入栈
            3.最后当表达式扫描完后，栈里的就是计算结果了

   ###   计算1+2*(3+4)-5


# 普通队列

   ## 先进先出
   ## 用数组模拟，要记录队头和队尾
    
   ## 常用操作：向队尾插入一个数，从队头弹出，判断队列是否为空
    
   ## int q[N], hh, tt = -1;
    
   ## 插入：q[++ tt] = x;
   ## 弹出：hh ++;
    
   ## 判断是否为空
     if (hh <= tt);// not empty;
     else ;// empty;

   ## 队头：stk[hh];
   ## 队尾：stk[tt];

# 单调栈

   ## 常见模型：找出每个数左边离它最近的比它大/小的数
    
   ## 单调递增栈：在保持栈内元素单调递增的前提下（如果栈顶元素大于要入栈的元素，将将其弹出），此时栈顶元素就是数组中左侧第一个比自己小的元素，将新元素入栈
    
   ## 单调递减栈：在保持栈内元素单调递减的前提下（如果栈顶元素小于要入栈的元素，则将其弹出），此时栈顶元素就是数组中左侧第一个比自己大的元素，将新元素入栈

# 拓扑排序
  ##将一个有向无环图的所有顶点线性排列，要求：若存在一条从A到B的路径，那么在序列中A出现在B的前面。
  ## 有向无环图一定存在一个入度为0的点。
   ## 步骤
        1.从图中选择一个入度为0的顶点并输出。
        2.从图中删除该顶点和所有以它为起点的有向边。
        3.重复 1 和 2 直到当前的图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。

    ## 一个有向无环图可以有一个或多个拓扑排序序列。

# 最短路问题分类：
  ## 单源最短路
  ### 所有边权都是正数
            朴素Dijkstra算法  （O(n^2)：n为点数，m为边数，适用于稠密图）
            堆优化版的Dijkstra算法  （O(m*logn)：n为点数，m为边数，适用于稀疏图）
 ### 存在负权边
            Bellman-Ford  （O(nm)）
            SPFA  （一般O(m)，最坏O(nm)）


  ## 多源汇最短路
  ### Floyd算法  （O(n^3)）


# 朴素Dijkstra算法
   ## 算法思路
    1.使用一个 dist[] 数组用来存储从 源点 到其它点的距离。初始化 dist[1] = 0 ，其它点的 dist 值为 正无穷大（可以使用一个很大的数来表示，比如 0x3f3f3f3f)。
    2.找到一个尚未确定并且距离起点距离最近的点 t。然后标记该节点。
    3.扫描节点 t 的所有 出边（t -> j)，如果 源点 到 j 的距离比源点到 t 再从 t 到 j 的距离 g[t][j] 之和大，那么就使 dist[j] = dist[t] + g[t][j]。
    4.重复步骤 2 和 3 直到所有的点都被标记。


